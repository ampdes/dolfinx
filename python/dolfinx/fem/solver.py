
import typing
from scipy.sparse.linalg import spsolve

import ufl
from dolfinx import default_scalar_type
from dolfinx.fem import assemble_matrix, assemble_vector, apply_lifting, set_bc
from dolfinx.fem.bcs import DirichletBC
from dolfinx.fem.forms import form as _create_form
from dolfinx.fem.function import Function as _Function


class LinearProblem:
    """Class for solving a linear variational problem of the form :math:`a(u, v) = L(v) \\,  \\forall v \\in V`
    using a serial linear algebra backend.

    """

    def __init__(self, a: ufl.Form, L: ufl.Form, bcs: typing.List[DirichletBC] = [],
                 u: typing.Optional[_Function] = None,
                 dtype=default_scalar_type,
                 form_compiler_options: typing.Optional[dict] = None,
                 jit_options: typing.Optional[dict] = None):
        """Initialize solver for a linear variational problem.

        Args:
            a: A bilinear UFL form, the left hand side of the
                variational problem.
            L: A linear UFL form, the right hand side of the variational
                problem.
            bcs: A list of Dirichlet boundary conditions.
            u: The solution function. It will be created if not provided.
            form_compiler_options: Options used in FFCx compilation of
                this form. Run ``ffcx --help`` at the commandline to see
                all available options.
            jit_options: Options used in CFFI JIT compilation of C
                code generated by FFCx. See `python/dolfinx/jit.py` for
                all available options. Takes priority over all other
                option values.

        Example::

            problem = LinearProblem(a, L, [bc0, bc1])
        """
        self._a = _create_form(a, dtype=dtype, form_compiler_options=form_compiler_options, jit_options=jit_options)
        self._A = None
        self._L = _create_form(L, dtype=dtype, form_compiler_options=form_compiler_options, jit_options=jit_options)
        self._b = None

        if self._a.mesh.comm.size > 1:
            raise RuntimeError("Serial solver cannot run with MPI")

        if u is None:
            # Extract function space from TrialFunction (which is at the
            # end of the argument list as it is numbered as 1, while the
            # Test function is numbered as 0)
            self.u = _Function(a.arguments()[-1].ufl_function_space())
        else:
            self.u = u

        self._x = self.u.x
        self.bcs = bcs

        def solver():
            A = self._A.to_scipy()
            b = self._b.array
            self.u.x.array[:] = spsolve(A, b)

        self._solver = solver

    def solve(self):
        """Solve the problem."""

        # Assemble lhs

        self._A = assemble_matrix(self._a, bcs=self.bcs)

        # Assemble rhs
        self._b = assemble_vector(self._L)

        # Apply boundary conditions to the rhs
        apply_lifting(self._b.array, [self._a], bcs=[self.bcs])
        # self._b.scatter_reverse(dolfinx.cpp.la.InsertMode.add)
        set_bc(self._b.array, self.bcs)

        # Solve linear system and update ghost values in the solution
        self._solver()
        # self.u.x.scatter_forward()

        return self.u

    @property
    def L(self):
        """The compiled linear form"""
        return self._L

    @property
    def a(self):
        """The compiled bilinear form"""
        return self._a

    @property
    def A(self):
        """Matrix operator"""
        return self._A

    @property
    def b(self):
        """Right-hand side vector"""
        return self._b

    @property
    def solver(self):
        """Linear solver object"""
        return self._solver
